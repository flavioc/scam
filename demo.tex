\documentclass{template}

\begin{document}

\title{AspectJ: An Approach to AOP}

\numberofauthors{2}

\author{
\alignauthor
Carlos ...\\
       \affaddr{Institute for Clarity in Documentation}\\
       \affaddr{1932 Wallamaloo Lane}\\
       \affaddr{Wallamaloo, New Zealand}\\
       \email{trovato@corporation.com}
% 2nd. author
\alignauthor
Flavio Cruz\\
       \affaddr{Faculdade de Ciencias da Universidade do Porto}\\
       \email{flaviocruz@gmail.com}
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
\date{\today}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}
The abstract...
\end{abstract}

\keywords{AOP, aspects, Java, OOP}

\section{Introduction}
Falar dos conceitos por detr√°s do aspect j, AOP, razoes para sua existencia, estrutura do report

\section{Aspect Oriented Programming}

\emph{Aspect Oriented Programming} (AOP) is a new programming paradigm that tries to tackle some problems
found in imperative and object oriented (OOP) paradigms \cite{Kiczales97aspect-orientedprogramming}. While those paradigms have made great progress towards
making software more modular and composable, they are unable to modularize and deal with \emph{crosscutting concerns}.
These concerns defy well-known abstractions like classes, methods and functions and crosscut the
natural modularity present in the implementation of complex systems by being dispersed
across multiple classes or methods. \cite{Kiczales01anoverview}

The objective of AOP is to provide new means of abstraction that can explicitly capture crosscutting concerns
and separate them from the \emph{core concerns}. These new abstractions are usually called \emph{aspects}
and they allow the programmer to easily develop, maintain and reuse crosscutting concerns. By placing
secundary concerns into a single, identificable place, aspects keep the main program logic cleaner and more easily
understable, without irrelevant details.

In AOP languages or language extensions, the aspect abstraction is defined by a \emph{joint point model}.
This model is composed of several concepts: well-defined points in the execution of the program,
called \emph{join points}; groups of joint points called \emph{pointcuts}; and method-like constructs used to
implement the crosscutting concerns, called the \emph{advices}. An aspect is thus an unit of modular
crosscutting implementation that is composed of pointcuts and the corresponding advices. By allowing the
use of pointcuts to describe certain points in the code, we can associate advices, thus allowing the execution
of secundary code at specific parts of the program (for example, before the execution of methods).

\section{Aspect J}

Comecar por descrever a ferramenta

\subsection{Installation}

\subsection{Using the Compiler}

\subsection{Joint Point Model}

\subsubsection{Pointcut descriptors}
\subsubsection{Advices}
\subsubsection{Aspects}

\subsection{A Complex Use Case}

aqui deviam aparecer dois exemplos: logging e observer pattern?

\section{Technical Details}

The main purpose of AspectJ is to insert advice code at the declared pointcuts and ensure that
both core and advice code runs well together, in a process called \emph{aspect weaving}.
As AspectJ is at its core only a specification, it does not force any implementation method.
However, the implemented tool itself tries to do most of the work during the compile-time, by
inserting the advice code directly into the pointcuts before compilation. This has the advantage of
allowing the compiler to catch errors earlier and increasing the efficiency of the final program.

Code not affected by aspects is compiled as traditional code, while code where advices apply are
transformed to insert static points corresponding to the dynamic joint points.
For pointcut descriptors like \texttt{cflow} or \texttt{instanceof}, the weaver must insert
code at the static points for runtime checking.

Before and after advices are compiled as standard methods and are called at the static points in
the program. Around advices are compiled into multiple methods, one for each static point in the code.
While this increases the code size, we trade that for boosted runtime efficiency of the code since
it is easier to access state through the call-stack and to implement the \texttt{proceed} statement
without costly runtime mechanisms.

\section{Conclusions}

As tipicas conclusoes \cite{Kiczales97aspect-orientedprogramming}

\bibliographystyle{abbrv}
\bibliography{refs}

\balancecolumns
\end{document}
