\documentclass{template}

\begin{document}

\title{AspectJ: An Approach to AOP}

\numberofauthors{2}

\author{
\alignauthor
Carlos ...\\
       \affaddr{Institute for Clarity in Documentation}\\
       \affaddr{1932 Wallamaloo Lane}\\
       \affaddr{Wallamaloo, New Zealand}\\
       \email{trovato@corporation.com}
% 2nd. author
\alignauthor
Flavio Cruz\\
       \affaddr{Faculdade de Ciencias da Universidade do Porto}\\
       \email{flaviocruz@gmail.com}
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
\date{\today}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}
Aspect Oriented Programming (AOP) is a new paradigm that tries to solve several problems of
Object Oriented Programming and Imperative Programming by modularizing crosscutting concerns.
In this paper we present a compiler called AspectJ that extends
the Java language with a new abstraction unit called the aspect. We will present the
how crosscutting concerns can be declared, first by showing the new constructs that support
the declaration of certain points of execution in the program, called the joint points, and the
advices, which associate a body of code to joint points. AspectJ implements aspects by weaving advice
code into standard code and then by compiling the result into JVM byte-code that can be 
executed by any implementation of the JVM.
 
\end{abstract}

\keywords{AOP, aspects, Java, OOP}

\section{Introduction}

Several paradigms such as \emph{Imperative Programming} and \emph{Object Oriented Programming} (OOP) were put forward in the last few years
to combat complexity in software systems by means of abstractions such as classes or methods. While these abstractions enable
more and more modularization of the system functionality, several concerns crosscut several modules of a program and make
the code less clean by obfuscating the important program logic. \emph{Aspect Oriented Programming} tries to solve this
with the introduction of the \emph{aspect} abstraction, where crosscutting concerns can be captured.

This paper presents the AspectJ compiler, an implementation of AOP for the Java language. This tool allows the declaration
of aspects as a class-like abstraction, where we can define the \emph{joint points} of the program and the corresponding
\emph{advice} declarations with the code that must be weaved into the program. AspectJ support for either static or dynamic joint points,
and offers several ways of declaring \emph{pointcuts}, which are groups of joint points.
We believe that the main advantage of AspectJ is bringing AOP to a very popular programming language and therefore to the average programmer.

The rest of the paper is organized as follows. First, we present the concepts behind AOP. Next, we present
AspectJ itself, first by showing instructions in how to use and install the compiler and then by presenting the \emph{joint point model},
that is, how the different components of aspects, such as pointcuts and advices, can be declared. With a good knowledge
of Aspect we then present a concrete use case, showing the potential of AOP and AspectJ. Finally, we present the technical details
behind this tool and we end by outlining some conclusions.

\section{Aspect Oriented Programming}

\emph{Aspect Oriented Programming} (AOP) is a new programming paradigm that tries to tackle some problems
found in imperative and object oriented (OOP) paradigms \cite{Kiczales97aspect-orientedprogramming}. While those paradigms have made great progress towards
making software more modular and composable, they are unable to modularize and deal with \emph{crosscutting concerns}.
These concerns defy well-known abstractions like classes, methods and functions and crosscut the
natural modularity present in the implementation of complex systems by being dispersed
across multiple classes or methods. \cite{Kiczales01anoverview}

The objective of AOP is to provide new means of abstraction that can explicitly capture crosscutting concerns
and separate them from the \emph{core concerns}. These new abstractions are usually called \emph{aspects}
and they allow the programmer to easily develop, maintain and reuse crosscutting concerns. By placing
secondary concerns into a single, identifiable place, aspects keep the main program logic cleaner and more easily
understandable, without irrelevant details.

In AOP languages or language extensions, the aspect abstraction is defined by a \emph{joint point model}.
This model is composed of several concepts: well-defined points in the execution of the program,
called \emph{join points}; groups of joint points called \emph{pointcuts}; and method-like constructs used to
implement the crosscutting concerns, called the \emph{advices}. An aspect is thus an unit of modular
crosscutting implementation that is composed of pointcuts and the corresponding advices. By allowing the
use of pointcuts to describe certain points in the code, we can associate advices, thus allowing the execution
of secondary code at specific parts of the program (for example, before the execution of methods).

\section{Aspect J}

Comecar por descrever a ferramenta

\subsection{Installation}

\subsection{Using the Compiler}

\subsection{Joint Point Model}

\subsubsection{Pointcut descriptors}
\subsubsection{Advices}
\subsubsection{Aspects}

\section{A Complex Use Case}

aqui deviam aparecer dois exemplos: logging e observer pattern?

\section{Technical Details}

The main purpose of AspectJ is to insert advice code at the declared pointcuts and ensure that
both core and advice code runs well together, in a process called \emph{aspect weaving}.
As AspectJ is at its core only a specification, it does not force any implementation method.
However, the implemented tool itself tries to do most of the work during the compile-time, by
inserting the advice code directly into the pointcuts before compilation. This has the advantage of
allowing the compiler to catch errors earlier and increasing the efficiency of the final program.

Code not affected by aspects is compiled as traditional code, while code where advices apply are
transformed to insert static points corresponding to the dynamic joint points.
For pointcut descriptors like \texttt{cflow} or \texttt{instanceof}, the weaver must insert
code at the static points for runtime checking.

Before and after advices are compiled as standard methods and are called at the static points in
the program. Around advices are compiled into multiple methods, one for each static point in the code.
While this increases the code size, we trade that for boosted runtime efficiency of the code since
it is easier to access state through the call-stack and to implement the \texttt{proceed} statement
without costly runtime mechanisms.

\section{Conclusions}

As tipicas conclusoes \cite{Kiczales97aspect-orientedprogramming}

\bibliographystyle{abbrv}
\bibliography{refs}

\balancecolumns
\end{document}
