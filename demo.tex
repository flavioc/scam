\documentclass{template}

\begin{document}

\title{AspectJ: An Approach to AOP}

\numberofauthors{2}

\author{
\alignauthor
Carlos Pereira\\
       \affaddr{Instituto de Engenharia Electronica e Telematica de Aveiro, Universidade de Aveiro}\\
       \email{carlospereira221@gmail.com}
% 2nd. author
\alignauthor
Flavio Cruz\\
       \affaddr{Faculdade de Ciencias da Universidade do Porto}\\
       \email{flaviocruz@gmail.com}
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
\date{\today}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}
Aspect Oriented Programming (AOP) is a new paradigm that tries to solve several problems of
Object Oriented Programming and Imperative Programming by modularizing crosscutting concerns.
In this paper we present a compiler called AspectJ that extends
the Java language with a new abstraction unit called the aspect. We will present the
how crosscutting concerns can be declared, first by showing the new constructs that support
the declaration of certain points of execution in the program, called the joint points, and the
advices, which associate a body of code to joint points. AspectJ implements aspects by weaving advice
code into standard code and then by compiling the result into JVM byte-code that can be
executed by any implementation of the JVM.
 
\end{abstract}

\keywords{AOP, aspects, Java, OOP}

\section{Introduction}

Several paradigms such as \emph{Imperative Programming} and \emph{Object Oriented Programming} (OOP) were put forward in the last few years
to combat complexity in software systems by means of abstractions such as classes or methods. While these abstractions enable
more and more modularization of the system functionality, several concerns crosscut several modules of a program and make
the code less clean by obfuscating the important program logic. \emph{Aspect Oriented Programming} tries to solve this
with the introduction of the \emph{aspect} abstraction, where crosscutting concerns can be captured.

This paper presents the AspectJ compiler, an implementation of AOP for the Java language. This tool allows the declaration
of aspects as a class-like abstraction, where we can define the \emph{joint points} of the program and the corresponding
\emph{advice} declarations with the code that must be weaved into the program. AspectJ support for either static or dynamic joint points,
and offers several ways of declaring \emph{pointcuts}, which are groups of joint points.
We believe that the main advantage of AspectJ is bringing AOP to a very popular programming language and therefore to the average programmer.

The rest of the paper is organized as follows. First, we present the concepts behind AOP. Next, we present
AspectJ itself, first by showing instructions in how to use and install the compiler and then by presenting the \emph{joint point model},
that is, how the different components of aspects, such as pointcuts and advices, can be declared. With a good knowledge
of Aspect we then present a concrete use case, showing the potential of AOP and AspectJ. Finally, we present the technical details
behind this tool and we end by outlining some conclusions.

\section{Aspect Oriented Programming}

\emph{Aspect Oriented Programming} (AOP) is a new programming paradigm that tries to tackle some problems
found in imperative and object oriented (OOP) paradigms \cite{Kiczales97aspect-orientedprogramming}. While those paradigms have made great progress towards
making software more modular and composable, they are unable to modularize and deal with \emph{crosscutting concerns}.
These concerns defy well-known abstractions like classes, methods and functions and crosscut the
natural modularity present in the implementation of complex systems by being dispersed
across multiple classes or methods. \cite{Kiczales01anoverview}

The objective of AOP is to provide new means of abstraction that can explicitly capture crosscutting concerns
and separate them from the \emph{core concerns}. These new abstractions are usually called \emph{aspects}
and they allow the programmer to easily develop, maintain and reuse crosscutting concerns. By placing
secundary concerns into a single, identificable place, aspects keep the main program logic cleaner and more easily
understable, without irrelevant details.

In AOP languages or language extensions, the aspect abstraction is defined by a \emph{joint point model}.
This model is composed of several concepts: well-defined points in the execution of the program,
called \emph{join points}; groups of joint points called \emph{pointcuts}; and method-like constructs used to
implement the crosscutting concerns, called the \emph{advices}. An aspect is thus an unit of modular
crosscutting implementation that is composed of pointcuts and the corresponding advices. By allowing the
use of pointcuts to describe certain points in the code, we can associate advices, thus allowing the execution
of secundary code at specific parts of the program (for example, before the execution of methods).

\section{Aspect J}

AspectJ was a project of research at Xerox Palo Alto Research Center, funded by Xerox, a U.S. Government grant (NISTATP), and a DARPA contract. It has since evolved through open-source releases to a strong user community and now operates as an open source project \cite{AspectJ}.

AspectJ is based on the AOP paradigm, aiming to help the developer by adding constructs to Java that enable the modular implementation of crosscutting concerns. Additionally it aims for code modularity and reusability.

In normal Java, it may be difficult to modularize some parts of the system like error-handling, testing, logging, persistence, to state a few. Normally, this kind of code tends to be spread out across the system, making future changes or additions difficult to perform. 

AspectJ was designed to answer these concerns. In order to facilitate its adoption by the programmers community, it is defined upholding two main properties \cite{Kiczales97aspect-orientedprogramming}:

\begin{itemize}
\item \textit{Upward compatibility} - all legal Java programs must be legal AspectJ programs;
\item \textit{Platform compatibility} - all legal AspectJ programs must run on standard Java virtual machines. 
\end{itemize}

These two principles set the road for how will the programmer use AspectJ. In typical Java projects, in order to compile the code, \textit{javac} is used. In AspectJ projects \textit{ajc} will be used. However, \textit{ajc} is not in truth a new compiler technology, but a copy of the Eclipse compiler with extensions to support the AspectJ language. 

These extensions are the main components of the joint point model which we will later describe.

\subsection{Installation}

The installation of AspectJ can be done by downloading the AspectJ binary at \url{http://eclipse.org/aspectj/downloads.php}. 
The AspectJ Development Tools which provides Eclipse platform based tool support for AOSD with AspectJ, is also available at \url{http://eclipse.org/ajdt/}. AJDT provides the user with a lot of functionalities, including code highlighting, indication of sections on the code where advices will be introduced, among others. Despite its usefulness, the utilization of AJDT is not on the scope of this paper.

The installation of AspectJ includes the AspectJ compiler, browser, documentation tool and Ant tasks. Most of these are included in the \textsc{aspectjtools.jar}. The main classes required to use AspectJ however, are included in the \textsc{aspectjrt.jar}. To install these two libraries, it is necessary to execute the downloaded \textsc{AspectJ.jar} using java:

\verb!java -jar aspectj.jar!

A wizard will be launched, where the user will have to specify the installation directory and the location of his JVM. Then he must only follow the instructions on screen and complete the installation.

\subsection{Using the Compiler}

The \textit{ajc} tool is the AspectJ language compiler. To demonstrate how to build an AspectJ program let's assume that ajc is installed and that we have a normal java class - MainClass.java - and an aspect class operating on that class - An Aspect.aj. The simplest way to compile this code is done by invoking the compiler and passing the classes as arguments:

\verb!ajc MainClass.java AnAspect.aj!

Note that in \textit{ajc} you must pass all your classes as arguments, since the compiler isn't capable of finding the classes in the folder for you~\cite{ajcsite}. The general invocation format for ajc is as follows: 

\verb!ajc [options] [file... |@file... |-arglist file...]!

\textit{ajc} will compile files listed in its command line or files found in the list file. The list filename can be specified 
either by "@" symbol or \textsc{-arglist} command option. A particularly useful option of \textit{ajc} is \textsc{-showWeaveInfo}. This allows the developer to analyze where have the aspect related code affected the source code. 

Once built, the project will run on any JVM (according to version). You need however to state the location of your \textsc{aspectjrt.jar} library when running the program in java.

\textit{ajc} possesses a lot of options~\cite{ajcsite} on how to link an aspect into existing Java code. The previous method was based on \textit{source compilation}. Another method is to use \textit{binary weaving}. An example follows:

\verb!ajc -inpath Application.jar NewAspect.aj -outjar ApplicationWithAspect.jar!

This method allows the developer to use an already compiled application and add the new aspects into a new application without recompiling previous code. This way, source code is not required in order to add aspects to an application. This is only possible due to AspectJ's bytecode transformation properties instead of source transformation.

\subsection{Joint Point Model}

In AOP, the join point model provides the common frame of reference that makes it possible for the execution of a program's aspect and non-aspect code to be properly coordinated~\cite{Kiczales97aspect-orientedprogramming}. As such, in AspectJ, crosscutting elements are defined by join points which represent well-defined points in the execution of the program. In order to do this, the AspectJ compiler can find places in the source code where some predefined operation are executed. 

AspectJ can possibly detect and operate on the following kinds of join points~\cite{Kiselev2002}: 
\begin{itemize}
\item method call and method execution; 
\item constructor call and constructor execution; 
\item initializer execution and static initializer execution; 
\item object preinitialization and object initialization; 
\item field reference and field assignment; 
\item exception handler execution.
\end{itemize}

In order to detect these join points, AspectJ defines in its grammar a syntactic construct called \textit{pointcut designator}.

\subsubsection{Pointcut designator}

A pointcut designator can be composed of several join points in addition to values inherent to the execution context of those joint points~\cite{Kiczales97aspect-orientedprogramming}. In AspectJ, it is possible to implement two types of pointcuts: \textit{primitive pointcuts} and \textit{user-defined pointcuts}.

Primitive pointcuts are used to identify the previously declared join points supported by AspectJ. Some relevant examples are: \texttt{execute(method)} - to identify whenever a given method is executed; \texttt{instanceof(object)} - matches if the object type is an instance of \texttt{myobject}; or \texttt{initializations(type)} - match all classes or object that possess the same specified type.

User-defined pointcuts define new pointcut designators. The following example shows the declaration of a new pointcut called \textit{printHello} that uses the primitive pointcut \textit{execute}: 

\verb!pointcut printHello() : execute (* print(..));!

\subsubsection{Advice}

An advice defines the code that will run at certain join points when picked out by pointcuts. In other words, it contains the business logic that will be executed when a certain pointcut is triggered~\cite{Kiselev2002}. AspectJ allows programmers to state their advices as a method-like mechanism embedding all code inside~\cite{Kiczales97aspect-orientedprogramming}. The three basic kinds of advices are~\cite{Kiselev2002}:

\begin{itemize}
\item \textit{after} - the goal of the after advice is to execute its body after the corresponding join point;
\item \textit{before} - the advice's body is executed before the join point picked by its pointcut is reached;
\item \textit{around} - the around advice enables the developer to replace the join point with an arbitrary code.
\end{itemize}

Using them, the programmer may define when will the code run according to the corresponding pointcut. Following is an example of an advice using the \textit{after} statement:

\verb!after() returning() : printHello() {!\\
\verb!     printf(" World");!\\
\verb!}!

In this example, the defined pointcut is \textit{printHello}. The advice states that the \textit{printf} method should be executed when the pointcut is detected, in this case, immediately after the previous declared instructions in the \textit{printHello} pointcut returns.

\subsubsection{Aspect}

%o que é
Aspects represent the basis for AOP as the principal items for crosscutting implementations on which all the pointcuts and their corresponding advices are declared. 

Aspects can be implemented similarly to Java classes, possessing properties like class extension, interface implementation or inner declarations. Unlike classes, aspects cannot be instantiated~\cite{Kiselev2002}. It is possible however to create abstract aspects and later extend these in other aspects.

Following is an example of an aspect using the previous declared pointcut and advice:

\verb!public aspect AnAspect {!\\
\verb!    pointcut printHello() : execution (* print(..));!\\\\
\verb!    after() returning() : printHello() {!\\
\verb!         printf("World");!\\
\verb!    }!\\\\
\verb!    before() : printHello() {!\\
\verb!         printf("This is an ");!\\
\verb!    }!\\
\verb!}!

As an example to describe this aspect, suppose that the declared \textit{print} method in the base code outputs the sentence \textit{"Hello"}. The included advices state that whenever the \textit{print} method is executed in the code, then the sentence \textit{"This is an"} will be printed right before and the sentence \textit{"World"} right after. In sum, an execution of the print method would output the sentence \textit{"This is an Hello World"}.

%%Omiti esta secção por falta de espaço presentemente...limite 3 paginas
%\subsection{A Complex Use Case}

%aqui deviam aparecer dois exemplos: logging e observer pattern?

\section{Technical Details}

The main purpose of AspectJ is to insert advice code at the declared pointcuts and ensure that
both core and advice code runs well together, in a process called \emph{aspect weaving}.
As AspectJ is at its core only a specification, it does not force any implementation method.
However, the implemented tool itself tries to do most of the work during the compile-time, by
inserting the advice code directly into the pointcuts before compilation. This has the advantage of
allowing the compiler to catch errors earlier and increasing the efficiency of the final program.

Code not affected by aspects is compiled as traditional code, while code where advices apply are
transformed to insert static points corresponding to the dynamic joint points.
For pointcut descriptors like \texttt{cflow} or \texttt{instanceof}, the weaver must insert
code at the static points for runtime checking.

Before and after advices are compiled as standard methods and are called at the static points in
the program. Around advices are compiled into multiple methods, one for each static point in the code.
While this increases the code size, we trade that for boosted runtime efficiency of the code since
it is easier to access state through the call-stack and to implement the \texttt{proceed} statement
without costly runtime mechanisms.

\section{Conclusions}

As tipicas conclusoes \cite{Kiczales97aspect-orientedprogramming}

\bibliographystyle{abbrv}
\bibliography{refs}

\balancecolumns
\end{document}
